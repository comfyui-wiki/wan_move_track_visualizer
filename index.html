<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WanMove Track Visualizer - ComfyUI Track Editor</title>
    
    <!-- Meta Information -->
    <meta name="description" content="Visual track editor and workflow generator for ComfyUI's WanMove model. Create, edit, and visualize motion trajectories with real-time preview.">
    <meta name="keywords" content="ComfyUI, WanMove, track editor, motion trajectories, visual editor, workflow generator">
    <meta name="author" content="ComfyUI Wiki">
    
    <!-- Project Links -->
    <link rel="canonical" href="https://github.com/comfyui-wiki/wan_move_track_visualizer">
    
    <!-- External Links (for reference) -->
    <!-- ComfyUI Main: https://github.com/comfyanonymous/ComfyUI/ -->
    <!-- ComfyUI Website: https://comfy.org -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 28px;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }
        
        .main-content {
            display: flex;
            height: calc(100vh - 140px);
        }
        
        .canvas-section {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-container {
            flex: 1;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fafafa;
            position: relative;
        }
        
        #trackCanvas {
            border: 1px solid #ccc;
            cursor: crosshair;
            background: white;
        }
        
        .controls-section {
            width: 350px;
            padding: 20px;
            background: #f8f9fa;
            border-left: 1px solid #eee;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .form-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .form-row label {
            flex: 1;
            font-weight: 500;
            color: #555;
            font-size: 13px;
        }
        
        .form-row input, .form-row select {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .form-row input[type="range"] {
            margin: 0 10px;
        }
        
        .range-display {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #666;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        /* Tab Styles */
        .tab-nav {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 15px;
        }
        
        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover {
            background: #f8f9fa;
            color: #333;
        }
        
        .tab-btn.active {
            color: #2c3e50;
            border-bottom-color: #3498db;
            background: #f8f9fa;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
            grid-column: span 2;
        }
        
        .btn-success:hover {
            background: #229954;
        }
        
        .export-section {
            margin-top: 20px;
        }
        
        .export-section textarea {
            width: 100%;
            height: 120px;
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            resize: vertical;
        }
        
        .track-info {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .track-info strong {
            color: #2c3e50;
        }
        
        .upload-section {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 10px;
            transition: border-color 0.3s;
        }
        
        .upload-section:hover {
            border-color: #3498db;
        }
        
        .upload-section.dragover {
            border-color: #3498db;
            background-color: #f8f9fa;
        }
        
        .upload-input {
            display: none;
        }
        
        .upload-button {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .upload-button:hover {
            background: #2980b9;
        }
        
        .image-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
        
        .fit-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .fit-btn {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .fit-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        
        .track-header {
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .track-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            flex: 1;
            padding: 5px 0;
            max-height: 80px;
            overflow-y: auto;
        }
        
        .track-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .track-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .track-list::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .track-list::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        .track-item {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            white-space: nowrap;
            min-width: fit-content;
        }
        
        .track-item:hover {
            border-color: #3498db;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .track-item.active {
            background-color: #3498db;
            border-color: #3498db;
            color: white;
            box-shadow: 0 2px 6px rgba(52, 152, 219, 0.3);
        }
        
        .track-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid #fff;
        }
        
        .track-item.active .track-color {
            border-color: rgba(255,255,255,0.8);
        }
        
        .track-name {
            font-size: 12px;
            font-weight: 500;
            margin-right: 6px;
        }
        
        .track-visibility {
            margin-left: 4px;
        }
        
        .track-visibility input[type="checkbox"] {
            margin: 0;
            width: 14px;
            height: 14px;
        }
        
        .track-controls {
            display: flex;
            gap: 8px;
        }
        
        .track-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .track-btn:hover {
            background: #f8f9fa;
            border-color: #3498db;
        }
        
        .track-btn.primary {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        
        .track-btn.primary:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WanMove Track Visualizer</h1>
            <p>Interactive tool for creating and visualizing motion tracks compatible with <a href="https://comfy.org" target="_blank" style="color: #3498db; text-decoration: none;">ComfyUI</a>'s WanMove model</p>
            <p style="margin-top: 5px; font-size: 14px; opacity: 0.8;">
                <a href="https://github.com/comfyui-wiki/wan_move_track_visualizer" target="_blank" style="color: #ecf0f1; text-decoration: none;">üìÅ GitHub Repository</a> | 
                <a href="https://github.com/comfyanonymous/ComfyUI/" target="_blank" style="color: #ecf0f1; text-decoration: none;">‚öôÔ∏è ComfyUI Main</a>
            </p>
        </div>
        
        <div class="main-content">
            <div class="canvas-section">
                <div class="track-header">
                    <span style="font-weight: 500; color: #2c3e50;">Tracks:</span>
                    <div class="track-list" id="trackList">
                        <!-- Track items will be dynamically added here -->
                    </div>
                    <div class="track-controls">
                        <button class="track-btn primary" onclick="addNewTrack()">Add</button>
                        <button class="track-btn" onclick="deleteActiveTrack()">Delete</button>
                        <button class="track-btn" onclick="undo()" id="undoBtn" disabled>‚Ü∂</button>
                        <button class="track-btn" onclick="redo()" id="redoBtn" disabled>‚Ü∑</button>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="trackCanvas" width="720" height="720"></canvas>
                </div>
                
                <div class="track-info">
                    <strong>Instructions:</strong> Click and drag on the canvas to set start/end points. 
                    Use the controls to adjust track parameters. Export generates data compatible with ComfyUI GenerateTracks node.
                    <br><strong>Note:</strong> All coordinates are normalized (0-1) and will be scaled to the specified width/height in the node.
                </div>
            </div>
            
            <div class="controls-section">
                <div class="control-group">
                    <h3>Image Upload</h3>
                    <div class="upload-section" id="uploadSection">
                        <input type="file" id="imageUpload" class="upload-input" accept="image/*">
                        <button type="button" class="upload-button" onclick="document.getElementById('imageUpload').click()">Choose Image</button>
                        <div>or drag & drop an image here</div>
                        <div class="image-info" id="imageInfo"></div>
                    </div>
                </div>
                
                <div class="control-group" id="imageScaleGroup" style="display: none;">
                    <h3>Image Scale (ComfyUI ImageScale)</h3>
                    <div class="form-row">
                        <label>Target Width:</label>
                        <input type="number" id="scaleWidth" value="0" min="0" max="4096" step="16">
                    </div>
                    <div class="form-row">
                        <label>Target Height:</label>
                        <input type="number" id="scaleHeight" value="0" min="0" max="4096" step="16">
                    </div>
                    <div class="form-row">
                        <label>Upscale Method:</label>
                        <select id="upscaleMethod">
                            <option value="nearest-exact">Nearest Exact</option>
                            <option value="bilinear" selected>Bilinear</option>
                            <option value="area">Area</option>
                            <option value="bicubic">Bicubic</option>
                            <option value="lanczos">Lanczos</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label>Crop:</label>
                        <select id="cropMethod">
                            <option value="disabled" selected>Disabled</option>
                            <option value="center">Center</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label>Scaled Size:</label>
                        <span id="scaledSizeInfo">-</span>
                    </div>
                    
                    <div class="button-group">
                        <button class="btn-primary" onclick="applyImageScale()">Apply Scale</button>
                        <button class="btn-secondary" onclick="resetImageScale()">Reset</button>
                    </div>
                </div>
                
                
                <div class="control-group">
                    <h3>Track Parameters</h3>
                    <div class="form-row">
                        <label>Start X:</label>
                        <input type="range" id="startX" min="0" max="1" step="0.01" value="0.1">
                        <span class="range-display" id="startXValue">0.10</span>
                    </div>
                    <div class="form-row">
                        <label>Start Y:</label>
                        <input type="range" id="startY" min="0" max="1" step="0.01" value="0.5">
                        <span class="range-display" id="startYValue">0.50</span>
                    </div>
                    <div class="form-row">
                        <label>End X:</label>
                        <input type="range" id="endX" min="0" max="1" step="0.01" value="0.9">
                        <span class="range-display" id="endXValue">0.90</span>
                    </div>
                    <div class="form-row">
                        <label>End Y:</label>
                        <input type="range" id="endY" min="0" max="1" step="0.01" value="0.5">
                        <span class="range-display" id="endYValue">0.50</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Bezier Curve</h3>
                    <div class="form-row">
                        <label>Enable Bezier:</label>
                        <input type="checkbox" id="bezierEnable">
                    </div>
                    <div class="form-row">
                        <label>Mid X:</label>
                        <input type="range" id="midX" min="0" max="1" step="0.01" value="0.5">
                        <span class="range-display" id="midXValue">0.50</span>
                    </div>
                    <div class="form-row">
                        <label>Mid Y:</label>
                        <input type="range" id="midY" min="0" max="1" step="0.01" value="0.3">
                        <span class="range-display" id="midYValue">0.30</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Animation Settings</h3>
                    <div class="form-row">
                        <label>Frames:</label>
                        <input type="number" id="numFrames" value="81" min="1" max="1024">
                    </div>
                    <div class="form-row">
                        <label>Tracks:</label>
                        <input type="number" id="numTracks" value="5" min="1" max="100">
                    </div>
                    <div class="form-row">
                        <label>Track Spread:</label>
                        <input type="range" id="trackSpread" min="0" max="0.1" step="0.001" value="0.025">
                        <span class="range-display" id="trackSpreadValue">0.025</span>
                    </div>
                    <div class="form-row">
                        <label>Interpolation:</label>
                        <select id="interpolation">
                            <option value="linear">Linear</option>
                            <option value="ease_in">Ease In</option>
                            <option value="ease_out">Ease Out</option>
                            <option value="ease_in_out">Ease In/Out</option>
                            <option value="constant">Constant</option>
                        </select>
                    </div>
                    
                    <div class="button-group">
                        <button class="btn-primary" onclick="updatePreview()">Update Preview</button>
                        <button class="btn-secondary" onclick="clearCanvas()">Clear</button>
                    </div>
                </div>
                
                <div class="control-group export-section">
                    <h3>Import/Export</h3>
                    
                    <!-- Tab Navigation -->
                    <div class="tab-nav">
                        <button class="tab-btn active" onclick="switchTab('workflow')" id="workflowTab">Workflow JSON</button>
                        <button class="tab-btn" onclick="switchTab('coords')" id="coordsTab">Track Coords</button>
                    </div>
                    
                    <!-- Workflow JSON Tab -->
                    <div class="tab-content active" id="workflowContent">
                        <div class="button-group">
                            <button class="btn-success" onclick="exportWorkflowJson()">Export</button>
                            <button class="btn-secondary" onclick="downloadExportData()">Download</button>
                        </div>
                        <div class="button-group" style="margin-top: 10px;">
                            <input type="file" id="importWorkflowFile" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                            <button class="btn-primary" onclick="document.getElementById('importWorkflowFile').click()">Import File</button>
                            <button class="btn-secondary" onclick="importFromTextarea()">Import Text</button>
                            <button class="btn-danger" onclick="clearImportData()">Clear All</button>
                        </div>
                    </div>
                    
                    <!-- Track Coords Tab -->
                    <div class="tab-content" id="coordsContent">
                        <div class="notice-warning" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 10px; margin-bottom: 15px; font-size: 13px; color: #856404;">
                            <strong>‚ö†Ô∏è Notice:</strong> The current Track Coords data format is not yet compatible with WanMoveTracksFromCoords node. We will fix this in a future update. For now, please use the <strong>Workflow JSON</strong> tab for ComfyUI integration.
                        </div>
                        <div class="button-group">
                            <button class="btn-primary" onclick="exportTrackData()">Export</button>
                            <button class="btn-secondary" onclick="downloadExportData()">Download</button>
                            <button class="btn-secondary" onclick="testTrackCoordsFormat()" style="font-size: 12px;">üîç Debug</button>
                        </div>
                        <div class="button-group" style="margin-top: 10px;">
                            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                            <button class="btn-primary" onclick="document.getElementById('importFile').click()">Import File</button>
                            <button class="btn-secondary" onclick="importFromTextarea()">Import Text</button>
                            <button class="btn-danger" onclick="clearImportData()">Clear All</button>
                        </div>
                    </div>
                    
                    <textarea id="exportOutput" placeholder="Data will appear here... You can also paste JSON to import." rows="8"></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('trackCanvas');
        const ctx = canvas.getContext('2d');
        
        let isDragging = false;
        let dragTarget = null;
        let dragTrackId = null;
        let allTracks = []; // Array of track objects
        let activeTrackId = 0; // Currently selected track
        let trackIdCounter = 0; // For generating unique IDs
        let backgroundImage = null;
        let originalImage = null;
        let scaledImage = null;
        let imageFitMode = 'contain';
        let imageScale = 1;
        let imageOffset = { x: 0, y: 0 };
        
        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const maxUndoSteps = 50;
        
        // Track colors
        const trackColors = [
            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#673ab7'
        ];
        
        // Initialize event listeners
        function initializeEventListeners() {
            // Range input listeners
            const rangeInputs = ['startX', 'startY', 'endX', 'endY', 'midX', 'midY', 'trackSpread'];
            rangeInputs.forEach(id => {
                const input = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                input.addEventListener('input', () => {
                    display.textContent = parseFloat(input.value).toFixed(2);
                    updateFromControls();
                });
            });
            
            
            // Other control listeners
            document.getElementById('bezierEnable').addEventListener('change', updatePreview);
            document.getElementById('interpolation').addEventListener('change', updatePreview);
            document.getElementById('numFrames').addEventListener('input', updatePreview);
            document.getElementById('numTracks').addEventListener('input', updatePreview);
            
            // Image scale listeners with real-time update
            document.getElementById('scaleWidth').addEventListener('input', function() {
                updateScaledSizeInfo();
                updateCanvasSizePreview();
            });
            document.getElementById('scaleHeight').addEventListener('input', function() {
                updateScaledSizeInfo();
                updateCanvasSizePreview();
            });
            
            // Canvas mouse events
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            
            // Image upload events
            const imageUpload = document.getElementById('imageUpload');
            const uploadSection = document.getElementById('uploadSection');
            
            imageUpload.addEventListener('change', handleImageUpload);
            
            // Drag and drop events
            uploadSection.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadSection.classList.add('dragover');
            });
            
            uploadSection.addEventListener('dragleave', () => {
                uploadSection.classList.remove('dragover');
            });
            
            uploadSection.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadSection.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    handleImageFile(files[0]);
                }
            });
        }
        
        function updateCanvasSize(width, height) {
            // Use provided dimensions or get from scaled image
            if (width && height) {
                canvas.width = width;
                canvas.height = height;
            } else if (backgroundImage) {
                canvas.width = backgroundImage.width;
                canvas.height = backgroundImage.height;
            } else {
                // Default size when no image
                canvas.width = 720;
                canvas.height = 720;
            }
            
            // Auto fit display if we have an image
            if (backgroundImage) {
                fitCanvasDisplay();
            } else {
                // Reset to default display size for manual canvas sizing
                canvas.style.width = '';
                canvas.style.height = '';
            }
            
            calculateImageTransform();
            updatePreview();
        }
        
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }
        
        function handleImageFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    backgroundImage = img;
                    scaledImage = null;
                    updateImageInfo(img, file);
                    showImageScaleControls(true);
                    resetImageScaleInputs(img);
                    calculateImageTransform();
                    updatePreview();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function updateImageInfo(img, file) {
            const fileSize = (file.size / 1024).toFixed(1);
            const info = `${img.width}√ó${img.height} ‚Ä¢ ${fileSize} KB ‚Ä¢ ${file.name}`;
            document.getElementById('imageInfo').textContent = info;
        }
        
        function showImageScaleControls(show) {
            document.getElementById('imageScaleGroup').style.display = show ? 'block' : 'none';
        }
        
        function resetImageScaleInputs(img) {
            document.getElementById('scaleWidth').value = 0;
            document.getElementById('scaleHeight').value = 0;
            updateScaledSizeInfo();
        }
        
        function updateScaledSizeInfo() {
            if (!originalImage) return;
            
            const targetWidth = parseInt(document.getElementById('scaleWidth').value) || 0;
            const targetHeight = parseInt(document.getElementById('scaleHeight').value) || 0;
            const scaledSize = calculateImageScaleSize(originalImage.width, originalImage.height, targetWidth, targetHeight);
            
            document.getElementById('scaledSizeInfo').textContent = `${scaledSize.width}√ó${scaledSize.height}`;
        }
        
        function updateCanvasSizePreview() {
            if (!originalImage) return;
            
            const targetWidth = parseInt(document.getElementById('scaleWidth').value) || 0;
            const targetHeight = parseInt(document.getElementById('scaleHeight').value) || 0;
            const scaledSize = calculateImageScaleSize(originalImage.width, originalImage.height, targetWidth, targetHeight);
            
            // Real-time preview: temporarily update canvas size
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = scaledSize.width;
            tempCanvas.height = scaledSize.height;
            
            // Apply scaling with crop handling
            const upscaleMethod = document.getElementById('upscaleMethod').value;
            const cropMethod = document.getElementById('cropMethod').value;
            
            tempCtx.imageSmoothingEnabled = upscaleMethod !== 'nearest-exact';
            if (upscaleMethod === 'bicubic' || upscaleMethod === 'lanczos') {
                tempCtx.imageSmoothingQuality = 'high';
            } else if (upscaleMethod === 'bilinear') {
                tempCtx.imageSmoothingQuality = 'medium';
            } else {
                tempCtx.imageSmoothingQuality = 'low';
            }
            
            applyImageScaling(tempCtx, originalImage, scaledSize.width, scaledSize.height, cropMethod);
            
            // Temporarily update background image for preview
            const img = new Image();
            img.onload = () => {
                const oldBg = backgroundImage;
                backgroundImage = img;
                updateCanvasSize(scaledSize.width, scaledSize.height);
                backgroundImage = oldBg; // Restore original for actual application
            };
            img.src = tempCanvas.toDataURL();
        }
        
        function calculateImageScaleSize(originalWidth, originalHeight, targetWidth, targetHeight) {
            // Implement ComfyUI ImageScale logic
            if (targetWidth === 0 && targetHeight === 0) {
                return { width: originalWidth, height: originalHeight };
            } else if (targetWidth === 0) {
                return { 
                    width: Math.max(1, Math.round(originalWidth * targetHeight / originalHeight)), 
                    height: targetHeight 
                };
            } else if (targetHeight === 0) {
                return { 
                    width: targetWidth, 
                    height: Math.max(1, Math.round(originalHeight * targetWidth / originalWidth)) 
                };
            } else {
                return { width: targetWidth, height: targetHeight };
            }
        }
        
        function applyImageScaling(ctx, sourceImage, targetWidth, targetHeight, cropMethod) {
            const sourceWidth = sourceImage.width;
            const sourceHeight = sourceImage.height;
            
            if (cropMethod === 'disabled') {
                // No crop: stretch to fit target dimensions (may cause distortion)
                ctx.drawImage(sourceImage, 0, 0, targetWidth, targetHeight);
            } else if (cropMethod === 'center') {
                // Center crop: maintain aspect ratio and crop from center
                const sourceAspect = sourceWidth / sourceHeight;
                const targetAspect = targetWidth / targetHeight;
                
                let drawWidth, drawHeight, sourceX, sourceY, sourceCropWidth, sourceCropHeight;
                
                if (sourceAspect > targetAspect) {
                    // Source is wider than target - crop horizontally
                    sourceCropHeight = sourceHeight;
                    sourceCropWidth = sourceHeight * targetAspect;
                    sourceX = (sourceWidth - sourceCropWidth) / 2;
                    sourceY = 0;
                } else {
                    // Source is taller than target - crop vertically
                    sourceCropWidth = sourceWidth;
                    sourceCropHeight = sourceWidth / targetAspect;
                    sourceX = 0;
                    sourceY = (sourceHeight - sourceCropHeight) / 2;
                }
                
                // Draw the cropped portion to fill the entire target canvas
                ctx.drawImage(
                    sourceImage,
                    sourceX, sourceY, sourceCropWidth, sourceCropHeight,
                    0, 0, targetWidth, targetHeight
                );
            }
        }
        
        function applyImageScale() {
            if (!originalImage) return;
            
            const targetWidth = parseInt(document.getElementById('scaleWidth').value) || 0;
            const targetHeight = parseInt(document.getElementById('scaleHeight').value) || 0;
            const upscaleMethod = document.getElementById('upscaleMethod').value;
            const cropMethod = document.getElementById('cropMethod').value;
            
            const scaledSize = calculateImageScaleSize(originalImage.width, originalImage.height, targetWidth, targetHeight);
            
            // Create a new canvas for scaling
            const scaleCanvas = document.createElement('canvas');
            const scaleCtx = scaleCanvas.getContext('2d');
            scaleCanvas.width = scaledSize.width;
            scaleCanvas.height = scaledSize.height;
            
            // Apply scaling with the selected method
            scaleCtx.imageSmoothingEnabled = upscaleMethod !== 'nearest-exact';
            if (upscaleMethod === 'bicubic' || upscaleMethod === 'lanczos') {
                scaleCtx.imageSmoothingQuality = 'high';
            } else if (upscaleMethod === 'bilinear') {
                scaleCtx.imageSmoothingQuality = 'medium';
            } else {
                scaleCtx.imageSmoothingQuality = 'low';
            }
            
            applyImageScaling(scaleCtx, originalImage, scaledSize.width, scaledSize.height, cropMethod);
            
            // Create scaled image
            const img = new Image();
            img.onload = () => {
                scaledImage = img;
                backgroundImage = img;
                
                // Update canvas to use the scaled image size
                updateCanvasSize(scaledSize.width, scaledSize.height);
            };
            img.src = scaleCanvas.toDataURL();
        }
        
        function resetImageScale() {
            if (!originalImage) return;
            
            backgroundImage = originalImage;
            scaledImage = null;
            resetImageScaleInputs(originalImage);
            
            // Reset canvas to original image size
            updateCanvasSize(originalImage.width, originalImage.height);
        }
        
        function setImageFit(mode) {
            // This function is now deprecated in favor of the scaling approach
            // Keep for backward compatibility but disable functionality
            console.warn('setImageFit is deprecated. Use Image Scale controls instead.');
        }
        
        function fitCanvasDisplay() {
            if (!backgroundImage) return;
            
            const logicalWidth = canvas.width;
            const logicalHeight = canvas.height;
            
            // Calculate max display size that fits in the container
            const container = document.querySelector('.canvas-container');
            const maxWidth = container.clientWidth - 40; // padding
            const maxHeight = container.clientHeight - 40;
            
            // Calculate scale to fit within container while maintaining aspect ratio
            const scaleX = maxWidth / logicalWidth;
            const scaleY = maxHeight / logicalHeight;
            const displayScale = Math.min(scaleX, scaleY, 1); // Don't upscale beyond 1:1
            
            // Set canvas display size
            const displayWidth = logicalWidth * displayScale;
            const displayHeight = logicalHeight * displayScale;
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Keep logical size for coordinates
            canvas.width = logicalWidth;
            canvas.height = logicalHeight;
        }
        
        function calculateImageTransform() {
            if (!backgroundImage) return;
            
            // Image is already scaled, just display it 1:1 within the logical canvas
            imageScale = 1;
            imageOffset.x = 0;
            imageOffset.y = 0;
        }
        
        function updateFromControls() {
            saveActiveTrackParams();
            updatePreview();
        }
        
        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            // Convert from display coordinates to logical coordinates
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            const pixelX = x * canvas.width;
            const pixelY = y * canvas.height;
            
            // Save state before starting drag operation
            saveState('drag_start');
            
            // First, check if clicking on a track label
            for (let label of trackLabels) {
                const distance = Math.sqrt((pixelX - label.x) ** 2 + (pixelY - label.y) ** 2);
                if (distance <= label.radius) {
                    setActiveTrack(label.trackId);
                    return;
                }
            }
            
            const activeTrack = getActiveTrack();
            if (!activeTrack) return;
            
            // Check if clicking near existing control points
            const threshold = 0.05;
            if (Math.abs(x - activeTrack.startPoint.x) < threshold && Math.abs(y - activeTrack.startPoint.y) < threshold) {
                dragTarget = 'start';
                dragTrackId = activeTrack.id;
                isDragging = true;
            } else if (Math.abs(x - activeTrack.endPoint.x) < threshold && Math.abs(y - activeTrack.endPoint.y) < threshold) {
                dragTarget = 'end';
                dragTrackId = activeTrack.id;
                isDragging = true;
            } else if (activeTrack.bezier && 
                       Math.abs(x - activeTrack.midPoint.x) < threshold && Math.abs(y - activeTrack.midPoint.y) < threshold) {
                dragTarget = 'mid';
                dragTrackId = activeTrack.id;
                isDragging = true;
            } else if (activeTrack.spreadControl1 &&
                       Math.abs(x - activeTrack.spreadControl1.x) < threshold && Math.abs(y - activeTrack.spreadControl1.y) < threshold) {
                dragTarget = 'spread';
                dragTrackId = activeTrack.id;
                isDragging = true;
            } else if (activeTrack.spreadControl2 &&
                       Math.abs(x - activeTrack.spreadControl2.x) < threshold && Math.abs(y - activeTrack.spreadControl2.y) < threshold) {
                dragTarget = 'spread';
                dragTrackId = activeTrack.id;
                isDragging = true;
            } else {
                // Check if clicking on any track to select it
                let clickedTrackId = findTrackAtPosition(x, y);
                if (clickedTrackId !== null && clickedTrackId !== activeTrack.id) {
                    setActiveTrack(clickedTrackId);
                    return;
                }
                
                // Set new start point for active track
                activeTrack.startPoint = { x, y };
                document.getElementById('startX').value = x;
                document.getElementById('startY').value = y;
                document.getElementById('startXValue').textContent = x.toFixed(2);
                document.getElementById('startYValue').textContent = y.toFixed(2);
                updatePreview();
            }
        }
        
        function onMouseMove(e) {
            if (!isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            // Convert from display coordinates to logical coordinates
            const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const y = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));
            
            const draggedTrack = allTracks.find(track => track.id === dragTrackId);
            if (!draggedTrack) return;
            
            if (dragTarget === 'start') {
                draggedTrack.startPoint = { x, y };
                document.getElementById('startX').value = x;
                document.getElementById('startY').value = y;
                document.getElementById('startXValue').textContent = x.toFixed(2);
                document.getElementById('startYValue').textContent = y.toFixed(2);
            } else if (dragTarget === 'end') {
                draggedTrack.endPoint = { x, y };
                document.getElementById('endX').value = x;
                document.getElementById('endY').value = y;
                document.getElementById('endXValue').textContent = x.toFixed(2);
                document.getElementById('endYValue').textContent = y.toFixed(2);
            } else if (dragTarget === 'mid') {
                draggedTrack.midPoint = { x, y };
                document.getElementById('midX').value = x;
                document.getElementById('midY').value = y;
                document.getElementById('midXValue').textContent = x.toFixed(2);
                document.getElementById('midYValue').textContent = y.toFixed(2);
            } else if (dragTarget === 'spread') {
                // Calculate new track spread based on mouse position
                if (draggedTrack.spreadCenter) {
                    const centerX = draggedTrack.spreadCenter.x;
                    const centerY = draggedTrack.spreadCenter.y;
                    
                    // Calculate distance from center to mouse position
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Convert distance back to track spread (normalized value)
                    // The spread is stored as normalized value, distance is in normalized coordinates
                    // We need to convert back considering the average of canvas dimensions
                    const pixelDistance = distance * Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / Math.sqrt(2);
                    const newSpread = pixelDistance / ((canvas.width + canvas.height) / 2);
                    
                    // Clamp the spread to reasonable bounds
                    draggedTrack.trackSpread = Math.max(0.001, Math.min(1.0, newSpread));
                    
                    // Update the UI slider
                    document.getElementById('trackSpread').value = draggedTrack.trackSpread;
                    document.getElementById('trackSpreadValue').textContent = draggedTrack.trackSpread.toFixed(3);
                }
            }
            
            updatePreview();
        }
        
        function onMouseUp() {
            isDragging = false;
            dragTarget = null;
            dragTrackId = null;
        }
        
        function generateTracksForSingle(trackObj) {
            const width = canvas.width;
            const height = canvas.height;
            const startXPx = trackObj.startPoint.x * width;
            const startYPx = trackObj.startPoint.y * height;
            const midXPx = trackObj.midPoint.x * width;
            const midYPx = trackObj.midPoint.y * height;
            const endXPx = trackObj.endPoint.x * width;
            const endYPx = trackObj.endPoint.y * height;
            const trackSpreadPx = trackObj.trackSpread * (width + height) / 2;
            
            const tracks = [];
            
            for (let frame = 0; frame < trackObj.numFrames; frame++) {
                const t = frame / (trackObj.numFrames - 1);
                let interpValue;
                
                // Apply interpolation
                switch (trackObj.interpolation) {
                    case 'constant':
                        interpValue = 0;
                        break;
                    case 'linear':
                        interpValue = t;
                        break;
                    case 'ease_in':
                        interpValue = t * t;
                        break;
                    case 'ease_out':
                        interpValue = 1 - (1 - t) * (1 - t);
                        break;
                    case 'ease_in_out':
                        interpValue = t * t * (3 - 2 * t);
                        break;
                    default:
                        interpValue = t;
                }
                
                let x, y, tangentX, tangentY;
                
                if (trackObj.bezier) {
                    const tInterp = interpValue;
                    const oneMinusT = 1 - tInterp;
                    x = oneMinusT * oneMinusT * startXPx + 2 * oneMinusT * tInterp * midXPx + tInterp * tInterp * endXPx;
                    y = oneMinusT * oneMinusT * startYPx + 2 * oneMinusT * tInterp * midYPx + tInterp * tInterp * endYPx;
                    tangentX = 2 * oneMinusT * (midXPx - startXPx) + 2 * tInterp * (endXPx - midXPx);
                    tangentY = 2 * oneMinusT * (midYPx - startYPx) + 2 * tInterp * (endYPx - midYPx);
                } else {
                    x = startXPx + (endXPx - startXPx) * interpValue;
                    y = startYPx + (endYPx - startYPx) * interpValue;
                    tangentX = endXPx - startXPx;
                    tangentY = endYPx - startYPx;
                }
                
                // Calculate perpendicular direction
                const length = Math.sqrt(tangentX * tangentX + tangentY * tangentY);
                let perpX = 1, perpY = 0;
                if (length > 0) {
                    perpX = -tangentY / length;
                    perpY = tangentX / length;
                }
                
                const frameData = [];
                for (let trackIdx = 0; trackIdx < trackObj.numTracks; trackIdx++) {
                    const offset = (trackIdx - (trackObj.numTracks - 1) / 2) * trackSpreadPx;
                    const trackX = x + perpX * offset;
                    const trackY = y + perpY * offset;
                    frameData.push({ x: trackX, y: trackY });
                }
                tracks.push(frameData);
            }
            
            return tracks;
        }
        
        function generateAllTracks() {
            // Save current active track params
            saveActiveTrackParams();
            
            // Generate tracks for all track objects
            allTracks.forEach(trackObj => {
                trackObj.generatedTracks = generateTracksForSingle(trackObj);
            });
        }
        
        function updatePreview() {
            generateAllTracks();
            drawTracks();
            updateExportData();
        }
        
        // Update export data in real-time
        function updateExportData() {
            const exportOutput = document.getElementById('exportOutput');
            if (exportOutput.value !== '') {
                // Check which export mode is currently being used
                const currentValue = exportOutput.value;
                try {
                    const parsed = JSON.parse(currentValue);
                    if (parsed && typeof parsed === 'object' && 'nodes' in parsed) {
                        // Currently showing workflow JSON
                        exportWorkflowJson();
                    } else {
                        // Currently showing track_coords
                        exportTrackData();
                    }
                } catch (e) {
                    // If it's not JSON, assume it's track_coords format
                    exportTrackData();
                }
            }
        }
        
        function drawTracks() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            trackLabels = []; // Clear previous label positions
            
            // Draw background image if available
            if (backgroundImage) {
                ctx.save();
                ctx.translate(imageOffset.x, imageOffset.y);
                ctx.scale(imageScale, imageScale);
                ctx.drawImage(backgroundImage, 0, 0);
                ctx.restore();
            } else {
                // Draw grid only if no background image
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = i * canvas.width / 10;
                    const y = i * canvas.height / 10;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // Draw all tracks
            allTracks.forEach((trackObj, trackIndex) => {
                if (!trackObj.visible || !trackObj.generatedTracks || trackObj.generatedTracks.length === 0) return;
                
                const tracks = trackObj.generatedTracks;
                const opacity = trackObj.active ? 1.0 : 0.4;
                const color = trackObj.color;
                const numTracks = tracks[0].length;
                
                // Set opacity for inactive tracks
                ctx.globalAlpha = opacity;
                
                // Draw track paths
                for (let trackIdx = 0; trackIdx < numTracks; trackIdx++) {
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = trackObj.active ? 3 : 2;
                    ctx.beginPath();
                    
                    for (let frameIdx = 0; frameIdx < tracks.length; frameIdx++) {
                        const point = tracks[frameIdx][trackIdx];
                        if (frameIdx === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw arrows along the path
                    if (trackObj.active) {
                        drawArrowsOnPath(tracks, trackIdx, color);
                    }
                    
                    // Track points removed - only arrows are shown
                }
                
                // Draw track number label at track center
                const centerFrameIdx = Math.floor(tracks.length / 2);
                const centerPoint = tracks[centerFrameIdx][Math.floor(numTracks / 2)];
                drawTrackLabel(centerPoint.x, centerPoint.y, trackIndex + 1, color, trackObj.active, trackObj.id);
            });
            
            // Reset alpha for control points
            ctx.globalAlpha = 1.0;
            
            // Draw control points for active track only
            const activeTrack = getActiveTrack();
            if (activeTrack) {
                // Start point
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(activeTrack.startPoint.x * canvas.width, activeTrack.startPoint.y * canvas.height, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(activeTrack.startPoint.x * canvas.width, activeTrack.startPoint.y * canvas.height, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // End point
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(activeTrack.endPoint.x * canvas.width, activeTrack.endPoint.y * canvas.height, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(activeTrack.endPoint.x * canvas.width, activeTrack.endPoint.y * canvas.height, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Mid point (bezier control)
                if (activeTrack.bezier) {
                    ctx.fillStyle = '#f39c12';
                    ctx.beginPath();
                    ctx.arc(activeTrack.midPoint.x * canvas.width, activeTrack.midPoint.y * canvas.height, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(activeTrack.midPoint.x * canvas.width, activeTrack.midPoint.y * canvas.height, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw bezier control lines
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(activeTrack.startPoint.x * canvas.width, activeTrack.startPoint.y * canvas.height);
                    ctx.lineTo(activeTrack.midPoint.x * canvas.width, activeTrack.midPoint.y * canvas.height);
                    ctx.lineTo(activeTrack.endPoint.x * canvas.width, activeTrack.endPoint.y * canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw track spread control points
                drawTrackSpreadControls(activeTrack);
            }
        }
        
        let trackLabels = []; // Store label positions for click detection
        
        // Draw track spread control points
        function drawTrackSpreadControls(track) {
            if (!track.generatedTracks || track.generatedTracks.length === 0) return;
            
            // Calculate middle point of the track path
            const midFrameIndex = Math.floor(track.numFrames / 2);
            const tracks = track.generatedTracks;
            
            // Get the center track position
            const centerTrackIndex = Math.floor(track.numTracks / 2);
            
            if (midFrameIndex >= tracks.length || centerTrackIndex >= tracks[midFrameIndex].length) return;
            
            const centerPoint = tracks[midFrameIndex][centerTrackIndex];
            
            // Calculate direction of the track at this point
            let directionX, directionY;
            if (track.bezier) {
                // For bezier curves, calculate tangent at mid point
                const t = 0.5;
                const oneMinusT = 1 - t;
                directionX = 2 * oneMinusT * (track.midPoint.x - track.startPoint.x) + 2 * t * (track.endPoint.x - track.midPoint.x);
                directionY = 2 * oneMinusT * (track.midPoint.y - track.startPoint.y) + 2 * t * (track.endPoint.y - track.midPoint.y);
            } else {
                // For linear tracks, direction is constant
                directionX = track.endPoint.x - track.startPoint.x;
                directionY = track.endPoint.y - track.startPoint.y;
            }
            
            // Normalize direction
            const length = Math.sqrt(directionX * directionX + directionY * directionY);
            if (length === 0) return;
            
            directionX /= length;
            directionY /= length;
            
            // Calculate perpendicular direction (rotate 90 degrees)
            const perpX = -directionY;
            const perpY = directionX;
            
            // Calculate spread distance in pixels
            const spreadDistance = track.trackSpread * (canvas.width + canvas.height) / 2;
            
            // Calculate spread control points
            const spreadPoint1X = centerPoint.x + perpX * spreadDistance;
            const spreadPoint1Y = centerPoint.y + perpY * spreadDistance;
            const spreadPoint2X = centerPoint.x - perpX * spreadDistance;
            const spreadPoint2Y = centerPoint.y - perpY * spreadDistance;
            
            // Draw spread indicator lines
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(spreadPoint1X, spreadPoint1Y);
            ctx.lineTo(spreadPoint2X, spreadPoint2Y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw spread control points
            ctx.fillStyle = '#9b59b6';
            
            // First spread control point
            ctx.beginPath();
            ctx.arc(spreadPoint1X, spreadPoint1Y, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(spreadPoint1X, spreadPoint1Y, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // Second spread control point  
            ctx.fillStyle = '#9b59b6';
            ctx.beginPath();
            ctx.arc(spreadPoint2X, spreadPoint2Y, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(spreadPoint2X, spreadPoint2Y, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // Store spread control points for interaction
            track.spreadControl1 = { x: spreadPoint1X / canvas.width, y: spreadPoint1Y / canvas.height };
            track.spreadControl2 = { x: spreadPoint2X / canvas.width, y: spreadPoint2Y / canvas.height };
            track.spreadCenter = { x: centerPoint.x / canvas.width, y: centerPoint.y / canvas.height };
        }
        
        function drawTrackLabel(x, y, trackNumber, color, isActive, trackId) {
            ctx.save();
            
            // Store label position for click detection
            const radius = isActive ? 15 : 12;
            trackLabels.push({
                x: x,
                y: y,
                radius: radius,
                trackId: trackId
            });
            
            // Add shadow for better visibility
            if (isActive) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
            }
            
            ctx.fillStyle = color;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = isActive ? 3 : 2;
            ctx.font = isActive ? 'bold 16px Arial' : 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw background circle
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Reset shadow for text
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Draw number
            ctx.fillStyle = 'white';
            ctx.fillText(trackNumber.toString(), x, y);
            ctx.restore();
        }
        
        function drawArrowsOnPath(tracks, trackIdx, color) {
            if (tracks.length < 2) return;
            
            ctx.fillStyle = color;
            const arrowSize = 8;
            const spacing = Math.max(3, Math.floor(tracks.length / 6)); // Show 6 arrows max
            
            for (let frameIdx = spacing; frameIdx < tracks.length; frameIdx += spacing) {
                const currentPoint = tracks[frameIdx][trackIdx];
                const prevPoint = tracks[frameIdx - 1][trackIdx];
                
                // Calculate arrow direction
                const dx = currentPoint.x - prevPoint.x;
                const dy = currentPoint.y - prevPoint.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length < 1) continue; // Skip if points are too close
                
                // Normalize direction
                const unitX = dx / length;
                const unitY = dy / length;
                
                // Calculate arrow position (slightly ahead of current point)
                const arrowX = currentPoint.x + unitX * 5;
                const arrowY = currentPoint.y + unitY * 5;
                
                // Draw arrow
                drawArrow(arrowX, arrowY, unitX, unitY, arrowSize, color);
            }
        }
        
        function drawArrow(x, y, dirX, dirY, size, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(dirY, dirX));
            
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            // Draw arrow shape
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size/2);
            ctx.lineTo(-size * 0.6, 0);
            ctx.lineTo(-size, size/2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        
        function findTrackAtPosition(x, y) {
            const threshold = 0.08;
            
            for (let trackIndex = 0; trackIndex < allTracks.length; trackIndex++) {
                const trackObj = allTracks[trackIndex];
                if (!trackObj.visible || !trackObj.generatedTracks || trackObj.generatedTracks.length === 0) continue;
                
                const tracks = trackObj.generatedTracks;
                
                // Check if clicking near track path
                for (let frameIdx = 0; frameIdx < tracks.length; frameIdx++) {
                    for (let trackIdx = 0; trackIdx < tracks[frameIdx].length; trackIdx++) {
                        const point = tracks[frameIdx][trackIdx];
                        const pointX = point.x / canvas.width;
                        const pointY = point.y / canvas.height;
                        
                        if (Math.abs(x - pointX) < threshold && Math.abs(y - pointY) < threshold) {
                            return trackObj.id;
                        }
                    }
                }
            }
            
            return null;
        }
        
        function clearCanvas() {
            allTracks.forEach(track => track.generatedTracks = []);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('exportOutput').value = '';
        }
        
        function exportTrackData() {
            const trackCoords = generateTrackCoords();
            
            // Validate the generated data
            try {
                const parsed = JSON.parse(trackCoords);
                if (validateTrackCoordsFormat(parsed)) {
                    document.getElementById('exportOutput').value = trackCoords;
                    console.log('Export successful:', parsed.length, 'tracks exported');
                } else {
                    alert('Generated data format is invalid. Please check the console for details.');
                }
            } catch (e) {
                alert('Error generating track coordinates: ' + e.message);
            }
        }
        
        function validateTrackCoordsFormat(data) {
            if (!Array.isArray(data)) {
                console.error('Track coords data must be an array');
                return false;
            }
            
            if (data.length === 0) {
                console.warn('No tracks to export');
                return true;
            }
            
            const expectedFrameCount = data[0].length;
            
            for (let i = 0; i < data.length; i++) {
                const track = data[i];
                
                if (!Array.isArray(track)) {
                    console.error(`Track ${i} is not an array`);
                    return false;
                }
                
                if (track.length !== expectedFrameCount) {
                    console.error(`Track ${i} has ${track.length} frames, expected ${expectedFrameCount}`);
                    return false;
                }
                
                for (let j = 0; j < track.length; j++) {
                    const frame = track[j];
                    if (!frame || typeof frame.x !== 'number' || typeof frame.y !== 'number') {
                        console.error(`Track ${i}, frame ${j} has invalid format:`, frame);
                        return false;
                    }
                }
            }
            
            console.log(`Validation passed: ${data.length} tracks, each with ${expectedFrameCount} frames`);
            return true;
        }
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.getElementById(tabName + 'Tab').classList.add('active');
            document.getElementById(tabName + 'Content').classList.add('active');
        }
        
        // Undo/Redo system
        function saveState(action = 'user_action') {
            const state = {
                allTracks: JSON.parse(JSON.stringify(allTracks)), // Deep copy
                activeTrackId: activeTrackId,
                trackIdCounter: trackIdCounter,
                action: action,
                timestamp: Date.now()
            };
            
            undoStack.push(state);
            
            // Limit stack size
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            redoStack = [];
            
            updateUndoRedoButtons();
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            // Save current state to redo stack
            const currentState = {
                allTracks: JSON.parse(JSON.stringify(allTracks)),
                activeTrackId: activeTrackId,
                trackIdCounter: trackIdCounter,
                action: 'undo_point',
                timestamp: Date.now()
            };
            redoStack.push(currentState);
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(previousState);
            
            updateUndoRedoButtons();
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            // Save current state to undo stack
            const currentState = {
                allTracks: JSON.parse(JSON.stringify(allTracks)),
                activeTrackId: activeTrackId,
                trackIdCounter: trackIdCounter,
                action: 'redo_point',
                timestamp: Date.now()
            };
            undoStack.push(currentState);
            
            // Restore next state
            const nextState = redoStack.pop();
            restoreState(nextState);
            
            updateUndoRedoButtons();
        }
        
        function restoreState(state) {
            allTracks = JSON.parse(JSON.stringify(state.allTracks)); // Deep copy
            activeTrackId = state.activeTrackId;
            trackIdCounter = state.trackIdCounter;
            
            updateTrackList();
            loadActiveTrackParams();
            updatePreview();
        }
        
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            
            // Update button titles with action info
            if (undoStack.length > 0) {
                const lastAction = undoStack[undoStack.length - 1];
                undoBtn.title = `Undo: ${lastAction.action}`;
            } else {
                undoBtn.title = 'Nothing to undo';
            }
            
            if (redoStack.length > 0) {
                const nextAction = redoStack[redoStack.length - 1];
                redoBtn.title = `Redo: ${nextAction.action}`;
            } else {
                redoBtn.title = 'Nothing to redo';
            }
        }
        
        function testTrackCoordsFormat() {
            console.clear();
            console.log('=== Track Coords Debug ===');
            
            if (allTracks.length === 0) {
                alert('No tracks to debug. Please create some tracks first.');
                return;
            }
            
            generateAllTracks();
            const visibleTracks = allTracks.filter(track => track.visible);
            
            console.log('Visible tracks:', visibleTracks.length);
            
            visibleTracks.forEach((track, index) => {
                console.group(`Track ${index + 1}: ${track.name}`);
                console.log('Config:', {
                    numFrames: track.numFrames,
                    numTracks: track.numTracks,
                    generatedLength: track.generatedTracks?.length || 0
                });
                
                if (track.generatedTracks && track.generatedTracks.length > 0) {
                    console.log('First frame sample:', track.generatedTracks[0]);
                    console.log('Frame data lengths:', track.generatedTracks.map(frame => frame?.length || 0));
                } else {
                    console.error('No generated tracks data!');
                }
                console.groupEnd();
            });
            
            // Test export
            try {
                const trackCoords = generateTrackCoords();
                const parsed = JSON.parse(trackCoords);
                console.log('Generated data structure:');
                console.log('Total tracks:', parsed.length);
                if (parsed.length > 0) {
                    console.log('Frames per track:', parsed[0].length);
                    console.log('Sample track[0][0]:', parsed[0][0]);
                }
            } catch (error) {
                console.error('Export failed:', error);
            }
            
            alert('Debug complete. Check browser console (F12) for detailed information.');
        }
        
        function downloadExportData() {
            const exportOutput = document.getElementById('exportOutput');
            const data = exportOutput.value;
            
            if (!data) {
                alert('No data to download! Please export something first.');
                return;
            }
            
            let filename = 'track_data';
            let contentType = 'application/json';
            
            // Determine file type and name based on content
            try {
                const parsed = JSON.parse(data);
                if (parsed && typeof parsed === 'object' && 'nodes' in parsed) {
                    filename = 'workflow.json';
                } else {
                    filename = 'track_coords.json';
                }
            } catch (e) {
                filename = 'track_coords.json';
            }
            
            // Create and download file
            const blob = new Blob([data], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Import functions
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = e.target.result;
                    importJsonData(jsonData);
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function importFromTextarea() {
            const exportOutput = document.getElementById('exportOutput');
            const data = exportOutput.value.trim();
            
            if (!data) {
                alert('Please paste JSON data in the text area first.');
                return;
            }
            
            importJsonData(data);
        }
        
        function importJsonData(jsonString) {
            try {
                const data = JSON.parse(jsonString);
                
                // Detect data type and import accordingly
                if (Array.isArray(data) && data.length > 0 && Array.isArray(data[0])) {
                    // Track coords format
                    importTrackCoords(data);
                } else if (data.nodes && Array.isArray(data.nodes)) {
                    // Workflow JSON format
                    importWorkflowJson(data);
                } else {
                    alert('Unrecognized JSON format. Expected track_coords array or ComfyUI workflow.');
                }
            } catch (error) {
                alert('Invalid JSON data: ' + error.message);
            }
        }
        
        function clearImportData() {
            if (confirm('Are you sure you want to clear all tracks and start fresh?')) {
                saveState('clear_all');
                allTracks = [];
                trackIdCounter = 0;
                activeTrackId = 0;
                document.getElementById('exportOutput').value = '';
                updateTrackList();
                updatePreview();
            }
        }
        
        // Import track coordinates and reverse-engineer track parameters
        function importTrackCoords(trackCoordsData) {
            try {
                saveState('import_coords');
                allTracks = [];
                trackIdCounter = 0;
                
                if (!Array.isArray(trackCoordsData) || trackCoordsData.length === 0) {
                    alert('No track data found in the imported file.');
                    return;
                }
                
                // Group tracks by similar motion patterns (assume tracks from same trajectory are sequential)
                const trackGroups = groupTracksByPattern(trackCoordsData);
                
                trackGroups.forEach((group, groupIndex) => {
                    const trackObj = reverseEngineerTrack(group, trackIdCounter++);
                    allTracks.push(trackObj);
                });
                
                // Set first track as active
                activeTrackId = allTracks.length > 0 ? allTracks[0].id : 0;
                
                updateTrackList();
                updatePreview();
                
                alert(`Successfully imported ${trackGroups.length} track groups with ${trackCoordsData.length} total tracks.`);
                
            } catch (error) {
                alert('Error importing track coordinates: ' + error.message);
            }
        }
        
        // Group tracks that appear to be from the same trajectory
        function groupTracksByPattern(trackCoordsData) {
            if (trackCoordsData.length === 0) return [];
            
            const groups = [];
            const frameCount = trackCoordsData[0].length;
            
            // For now, group tracks that have similar start/end patterns
            // This is a heuristic approach - tracks with similar motion vectors likely belong together
            let currentGroup = [trackCoordsData[0]];
            let groupStartPoint = trackCoordsData[0][0];
            let groupEndPoint = trackCoordsData[0][frameCount - 1];
            
            for (let i = 1; i < trackCoordsData.length; i++) {
                const track = trackCoordsData[i];
                const startPoint = track[0];
                const endPoint = track[frameCount - 1];
                
                // Calculate if this track is close enough to be part of current group
                const startDistance = Math.sqrt(Math.pow(startPoint.x - groupStartPoint.x, 2) + Math.pow(startPoint.y - groupStartPoint.y, 2));
                const endDistance = Math.sqrt(Math.pow(endPoint.x - groupEndPoint.x, 2) + Math.pow(endPoint.y - groupEndPoint.y, 2));
                
                // If tracks are close (within reasonable spread distance), group them
                const spreadThreshold = Math.min(canvas.width, canvas.height) * 0.1; // 10% of canvas size
                
                if (startDistance < spreadThreshold && endDistance < spreadThreshold) {
                    currentGroup.push(track);
                } else {
                    // Start new group
                    groups.push(currentGroup);
                    currentGroup = [track];
                    groupStartPoint = startPoint;
                    groupEndPoint = endPoint;
                }
            }
            
            // Add the last group
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }
            
            return groups;
        }
        
        // Reverse engineer track parameters from coordinate data
        function reverseEngineerTrack(trackGroup, trackId) {
            const firstTrack = trackGroup[0];
            const frameCount = firstTrack.length;
            const trackCount = trackGroup.length;
            
            // Find center track (middle track in the group)
            const centerTrackIndex = Math.floor(trackCount / 2);
            const centerTrack = trackGroup[centerTrackIndex];
            
            // Extract start and end points (normalized coordinates)
            const startPoint = {
                x: centerTrack[0].x / canvas.width,
                y: centerTrack[0].y / canvas.height
            };
            
            const endPoint = {
                x: centerTrack[frameCount - 1].x / canvas.width,
                y: centerTrack[frameCount - 1].y / canvas.height
            };
            
            // Estimate mid point for bezier (use middle frame of center track)
            const midFrameIndex = Math.floor(frameCount / 2);
            const midPoint = {
                x: centerTrack[midFrameIndex].x / canvas.width,
                y: centerTrack[midFrameIndex].y / canvas.height
            };
            
            // Check if path appears to be bezier (non-linear)
            const isBezier = detectBezierCurve(centerTrack);
            
            // Estimate track spread based on distance between parallel tracks
            let trackSpread = 0;
            if (trackCount > 1) {
                // Calculate average distance between adjacent tracks
                let totalSpread = 0;
                let spreadSamples = 0;
                
                for (let frameIndex = 0; frameIndex < frameCount; frameIndex += Math.floor(frameCount / 5)) {
                    for (let i = 0; i < trackGroup.length - 1; i++) {
                        const dist = Math.sqrt(
                            Math.pow(trackGroup[i + 1][frameIndex].x - trackGroup[i][frameIndex].x, 2) +
                            Math.pow(trackGroup[i + 1][frameIndex].y - trackGroup[i][frameIndex].y, 2)
                        );
                        totalSpread += dist;
                        spreadSamples++;
                    }
                }
                
                if (spreadSamples > 0) {
                    const avgSpread = totalSpread / spreadSamples;
                    trackSpread = avgSpread / ((canvas.width + canvas.height) / 2);
                }
            }
            
            // Create track object
            const trackObj = {
                id: trackId,
                name: `Imported Track ${trackId + 1}`,
                color: trackColors[trackId % trackColors.length],
                visible: true,
                active: trackId === 0,
                startPoint: startPoint,
                endPoint: endPoint,
                midPoint: midPoint,
                bezier: isBezier,
                interpolation: 'linear', // Default to linear
                numFrames: frameCount,
                numTracks: trackCount,
                trackSpread: Math.max(0.001, Math.min(1.0, trackSpread)),
                generatedTracks: []
            };
            
            // Pre-populate generated tracks with imported data
            trackObj.generatedTracks = convertCoordsToTrackFormat(trackGroup);
            
            return trackObj;
        }
        
        // Detect if a track follows a bezier curve pattern
        function detectBezierCurve(track) {
            if (track.length < 5) return false;
            
            const start = track[0];
            const end = track[track.length - 1];
            
            // Check if middle points deviate significantly from linear path
            let maxDeviation = 0;
            
            for (let i = 1; i < track.length - 1; i++) {
                const t = i / (track.length - 1);
                // Linear interpolation point
                const linearX = start.x + (end.x - start.x) * t;
                const linearY = start.y + (end.y - start.y) * t;
                
                // Actual point
                const actualX = track[i].x;
                const actualY = track[i].y;
                
                // Calculate deviation
                const deviation = Math.sqrt(Math.pow(actualX - linearX, 2) + Math.pow(actualY - linearY, 2));
                maxDeviation = Math.max(maxDeviation, deviation);
            }
            
            // If deviation is significant compared to track length, it's likely bezier
            const trackLength = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            return maxDeviation > trackLength * 0.1; // 10% deviation threshold
        }
        
        // Convert coordinate format back to our internal track format
        function convertCoordsToTrackFormat(trackGroup) {
            const frameCount = trackGroup[0].length;
            const tracks = [];
            
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                const frameData = [];
                for (let trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
                    frameData.push({
                        x: trackGroup[trackIndex][frameIndex].x,
                        y: trackGroup[trackIndex][frameIndex].y
                    });
                }
                tracks.push(frameData);
            }
            
            return tracks;
        }
        
        // Import ComfyUI workflow and extract track parameters
        function importWorkflowJson(workflowData) {
            try {
                saveState('import_workflow');
                allTracks = [];
                trackIdCounter = 0;
                
                const generateTracksNodes = workflowData.nodes.filter(node => node.type === 'GenerateTracks');
                
                if (generateTracksNodes.length === 0) {
                    alert('No GenerateTracks nodes found in the workflow.');
                    return;
                }
                
                generateTracksNodes.forEach((node, index) => {
                    const params = node.widgets_values;
                    if (params && params.length >= 13) {
                        const trackObj = {
                            id: trackIdCounter++,
                            name: `Imported Track ${trackIdCounter}`,
                            color: trackColors[(trackIdCounter - 1) % trackColors.length],
                            visible: true,
                            active: index === 0,
                            startPoint: { x: params[2], y: params[3] },
                            endPoint: { x: params[4], y: params[5] },
                            midPoint: { x: params[10], y: params[11] },
                            bezier: params[9],
                            interpolation: params[12],
                            numFrames: params[6],
                            numTracks: params[7],
                            trackSpread: params[8],
                            generatedTracks: []
                        };
                        
                        allTracks.push(trackObj);
                    }
                });
                
                // Set first track as active
                activeTrackId = allTracks.length > 0 ? allTracks[0].id : 0;
                
                updateTrackList();
                updatePreview();
                
                alert(`Successfully imported ${generateTracksNodes.length} tracks from ComfyUI workflow.`);
                
            } catch (error) {
                alert('Error importing workflow: ' + error.message);
            }
        }
        
        function generateTrackNode(track, nodeId, posX, posY) {
            return {
                id: nodeId,
                type: "GenerateTracks",
                pos: [posX, posY],
                size: [270, 366],
                flags: {},
                order: nodeId - 1,
                mode: 0,
                inputs: [
                    {
                        name: "track_mask",
                        shape: 7,
                        type: "MASK",
                        link: null
                    }
                ],
                outputs: [
                    {
                        name: "TRACKS",
                        type: "TRACKS",
                        links: null
                    },
                    {
                        name: "track_length",
                        type: "INT",
                        links: null
                    }
                ],
                properties: {
                    "Node name for S&R": "GenerateTracks"
                },
                widgets_values: [
                    canvas.width,           // width
                    canvas.height,          // height
                    track.startPoint.x,     // start_x
                    track.startPoint.y,     // start_y
                    track.endPoint.x,       // end_x
                    track.endPoint.y,       // end_y
                    track.numFrames,        // num_frames
                    track.numTracks,        // num_tracks
                    track.trackSpread,      // track_spread
                    track.bezier,           // bezier
                    track.midPoint.x,       // mid_x
                    track.midPoint.y,       // mid_y
                    track.interpolation     // interpolation
                ]
            };
        }
        
        function generateConcatNode(nodeId, posX, posY, inputIds) {
            const node = {
                id: nodeId,
                type: "WanMoveConcatTrack",
                pos: [posX, posY],
                size: [200, 100],
                flags: {},
                order: nodeId - 1,
                mode: 0,
                inputs: [
                    {
                        name: "tracks_1",
                        type: "TRACKS",
                        link: inputIds.length > 0 ? (nodeId - 1) * 2 : null
                    },
                    {
                        name: "tracks_2",
                        type: "TRACKS", 
                        link: inputIds.length > 1 ? (nodeId - 2) * 2 : null
                    }
                ],
                outputs: [
                    {
                        name: "TRACKS",
                        type: "TRACKS",
                        links: null
                    }
                ],
                properties: {
                    "Node name for S&R": "WanMoveConcatTrack"
                },
                widgets_values: []
            };
            
            return node;
        }
        
        function exportWorkflowJson() {
            generateAllTracks();
            
            const visibleTracks = allTracks.filter(track => track.visible);
            if (visibleTracks.length === 0) {
                alert('No visible tracks to export!');
                return;
            }
            
            const nodes = [];
            const links = [];
            let nodeId = 1;
            let linkId = 1;
            
            // Generate GenerateTracks nodes
            const trackNodeIds = [];
            visibleTracks.forEach((track, index) => {
                const posX = 100 + (index % 3) * 300;  // 3 columns
                const posY = 100 + Math.floor(index / 3) * 400;  // Row spacing
                const node = generateTrackNode(track, nodeId, posX, posY);
                nodes.push(node);
                trackNodeIds.push(nodeId);
                nodeId++;
            });
            
            // Generate WanMoveConcatTrack nodes if multiple tracks
            if (visibleTracks.length > 1) {
                let currentTrackIds = [...trackNodeIds];
                let concatY = 600;
                
                while (currentTrackIds.length > 1) {
                    const newConcatIds = [];
                    
                    for (let i = 0; i < currentTrackIds.length; i += 2) {
                        if (i + 1 < currentTrackIds.length) {
                            // Create concat node for pair
                            const concatNode = generateConcatNode(nodeId, 500, concatY, [currentTrackIds[i], currentTrackIds[i + 1]]);
                            
                            // Add links
                            const trackId1 = currentTrackIds[i];
                            const trackId2 = currentTrackIds[i + 1];
                            
                            links.push([
                                linkId++,
                                trackId1,
                                0,
                                nodeId,
                                0,
                                "TRACKS"
                            ]);
                            
                            links.push([
                                linkId++,
                                trackId2,
                                0,
                                nodeId,
                                1,
                                "TRACKS"
                            ]);
                            
                            // Update concat node links
                            concatNode.inputs[0].link = linkId - 2;
                            concatNode.inputs[1].link = linkId - 1;
                            
                            nodes.push(concatNode);
                            newConcatIds.push(nodeId);
                            nodeId++;
                        } else {
                            // Odd track, carry forward
                            newConcatIds.push(currentTrackIds[i]);
                        }
                    }
                    
                    currentTrackIds = newConcatIds;
                    concatY += 150;
                }
            }
            
            // Update node outputs with links
            nodes.forEach(node => {
                const nodeLinks = links.filter(link => link[1] === node.id);
                if (nodeLinks.length > 0) {
                    node.outputs[0].links = nodeLinks.map(link => link[0]);
                }
            });
            
            const workflow = {
                id: generateUUID(),
                revision: 0,
                last_node_id: nodeId - 1,
                last_link_id: linkId - 1,
                nodes: nodes,
                links: links,
                groups: [],
                config: {},
                extra: {
                    workflowRendererVersion: "LG",
                    ds: {
                        scale: 1.0,
                        offset: [0, 0]
                    }
                },
                version: 0.4
            };
            
            document.getElementById('exportOutput').value = JSON.stringify(workflow, null, 2);
        }
        
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Generate track_coords format for WanMoveTracksFromCoords node
        function generateTrackCoords() {
            generateAllTracks();
            
            const visibleTracks = allTracks.filter(track => track.visible);
            if (visibleTracks.length === 0) {
                return "[]";
            }
            
            const trackCoords = [];
            
            visibleTracks.forEach(track => {
                // Ensure track data is properly generated
                if (!track.generatedTracks || track.generatedTracks.length === 0) {
                    console.warn('Track has no generated data:', track.name);
                    return; // Skip tracks with no data
                }
                
                console.log(`Processing track: ${track.name}, frames: ${track.numFrames}, tracks: ${track.numTracks}, generated: ${track.generatedTracks.length}`);
                
                // For each track, we need to create multiple sub-tracks based on numTracks
                for (let trackIndex = 0; trackIndex < track.numTracks; trackIndex++) {
                    const trackFrames = [];
                    for (let frameIndex = 0; frameIndex < track.numFrames; frameIndex++) {
                        // Access the coordinate using the correct data structure
                        if (frameIndex < track.generatedTracks.length && trackIndex < track.generatedTracks[frameIndex].length) {
                            const point = track.generatedTracks[frameIndex][trackIndex];
                            
                            trackFrames.push({
                                x: Math.round(point.x),
                                y: Math.round(point.y)
                            });
                        } else {
                            console.error(`Missing data at frame ${frameIndex}, track ${trackIndex}. Generated length: ${track.generatedTracks.length}, frame data length: ${track.generatedTracks[frameIndex]?.length || 'undefined'}`);
                            // Skip incomplete tracks
                            break;
                        }
                    }
                    // Only add tracks with complete frame data
                    if (trackFrames.length === track.numFrames) {
                        trackCoords.push(trackFrames);
                        console.log(`Added track ${trackIndex} with ${trackFrames.length} frames`);
                    } else {
                        console.warn(`Skipped incomplete track ${trackIndex}: expected ${track.numFrames} frames, got ${trackFrames.length}`);
                    }
                }
            });
            
            // Validate final data structure
            if (trackCoords.length > 0) {
                const frameCount = trackCoords[0].length;
                const isValid = trackCoords.every(track => track.length === frameCount);
                
                if (!isValid) {
                    console.error('Inconsistent frame counts detected!');
                    trackCoords.forEach((track, index) => {
                        console.log(`Track ${index}: ${track.length} frames`);
                    });
                } else {
                    console.log(`Generated ${trackCoords.length} tracks, each with ${frameCount} frames`);
                }
            }
            
            return JSON.stringify(trackCoords, null, 2);
        }
        
        // Track management functions
        function createDefaultTrack(id) {
            return {
                id: id,
                name: `Track ${id + 1}`,
                color: trackColors[id % trackColors.length],
                visible: true,
                active: id === 0,
                startPoint: { x: 0.1, y: 0.5 },
                endPoint: { x: 0.9, y: 0.5 },
                midPoint: { x: 0.5, y: 0.3 },
                bezier: false,
                interpolation: 'linear',
                numFrames: 81,
                numTracks: 5,
                trackSpread: 0.025,
                generatedTracks: []
            };
        }
        
        function initializeTracks() {
            allTracks = [createDefaultTrack(trackIdCounter++)];
            activeTrackId = 0;
            updateTrackList();
            loadActiveTrackParams();
        }
        
        function addNewTrack() {
            saveState('add_track');
            const newTrack = createDefaultTrack(trackIdCounter++);
            allTracks.push(newTrack);
            setActiveTrack(newTrack.id);
            updateTrackList();
            updatePreview();
        }
        
        function deleteActiveTrack() {
            if (allTracks.length <= 1) return; // Keep at least one track
            
            saveState('delete_track');
            allTracks = allTracks.filter(track => track.id !== activeTrackId);
            
            // Set new active track
            if (allTracks.length > 0) {
                setActiveTrack(allTracks[0].id);
            }
            
            updateTrackList();
            updatePreview();
        }
        
        function setActiveTrack(trackId) {
            // Save current active track params before switching
            saveActiveTrackParams();
            
            // Update active states
            allTracks.forEach(track => track.active = false);
            const newActiveTrack = allTracks.find(track => track.id === trackId);
            if (newActiveTrack) {
                newActiveTrack.active = true;
                activeTrackId = trackId;
                loadActiveTrackParams();
                updateTrackList();
                updatePreview();
            }
        }
        
        function getActiveTrack() {
            return allTracks.find(track => track.id === activeTrackId);
        }
        
        function saveActiveTrackParams() {
            const activeTrack = getActiveTrack();
            if (!activeTrack) return;
            
            activeTrack.startPoint.x = parseFloat(document.getElementById('startX').value);
            activeTrack.startPoint.y = parseFloat(document.getElementById('startY').value);
            activeTrack.endPoint.x = parseFloat(document.getElementById('endX').value);
            activeTrack.endPoint.y = parseFloat(document.getElementById('endY').value);
            activeTrack.midPoint.x = parseFloat(document.getElementById('midX').value);
            activeTrack.midPoint.y = parseFloat(document.getElementById('midY').value);
            activeTrack.bezier = document.getElementById('bezierEnable').checked;
            activeTrack.interpolation = document.getElementById('interpolation').value;
            activeTrack.numFrames = parseInt(document.getElementById('numFrames').value);
            activeTrack.numTracks = parseInt(document.getElementById('numTracks').value);
            activeTrack.trackSpread = parseFloat(document.getElementById('trackSpread').value);
        }
        
        function loadActiveTrackParams() {
            const activeTrack = getActiveTrack();
            if (!activeTrack) return;
            
            document.getElementById('startX').value = activeTrack.startPoint.x;
            document.getElementById('startY').value = activeTrack.startPoint.y;
            document.getElementById('endX').value = activeTrack.endPoint.x;
            document.getElementById('endY').value = activeTrack.endPoint.y;
            document.getElementById('midX').value = activeTrack.midPoint.x;
            document.getElementById('midY').value = activeTrack.midPoint.y;
            document.getElementById('bezierEnable').checked = activeTrack.bezier;
            document.getElementById('interpolation').value = activeTrack.interpolation;
            document.getElementById('numFrames').value = activeTrack.numFrames;
            document.getElementById('numTracks').value = activeTrack.numTracks;
            document.getElementById('trackSpread').value = activeTrack.trackSpread;
            
            // Update display values
            document.getElementById('startXValue').textContent = activeTrack.startPoint.x.toFixed(2);
            document.getElementById('startYValue').textContent = activeTrack.startPoint.y.toFixed(2);
            document.getElementById('endXValue').textContent = activeTrack.endPoint.x.toFixed(2);
            document.getElementById('endYValue').textContent = activeTrack.endPoint.y.toFixed(2);
            document.getElementById('midXValue').textContent = activeTrack.midPoint.x.toFixed(2);
            document.getElementById('midYValue').textContent = activeTrack.midPoint.y.toFixed(2);
            document.getElementById('trackSpreadValue').textContent = activeTrack.trackSpread.toFixed(3);
        }
        
        function updateTrackList() {
            const trackList = document.getElementById('trackList');
            trackList.innerHTML = '';
            
            allTracks.forEach(track => {
                const trackItem = document.createElement('div');
                trackItem.className = `track-item ${track.active ? 'active' : ''}`;
                trackItem.onclick = () => setActiveTrack(track.id);
                
                trackItem.innerHTML = `
                    <div class="track-color" style="background-color: ${track.color}"></div>
                    <span class="track-name">${track.name}</span>
                    <div class="track-visibility">
                        <input type="checkbox" ${track.visible ? 'checked' : ''} 
                               onclick="event.stopPropagation(); toggleTrackVisibility(${track.id})" />
                    </div>
                `;
                
                trackList.appendChild(trackItem);
            });
            
            // Auto-scroll to active track if needed
            const activeItem = trackList.querySelector('.track-item.active');
            if (activeItem) {
                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        function toggleTrackVisibility(trackId) {
            const track = allTracks.find(t => t.id === trackId);
            if (track) {
                track.visible = !track.visible;
                updatePreview();
            }
        }
        
        // Initialize the application
        initializeEventListeners();
        initializeTracks();
        updateUndoRedoButtons();
        updatePreview();
    </script>
</body>
</html>